<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Tag: Hardware | 随写 - XinoAssassin&#39;s Blog</title>
  
  <meta name="author" content="XinoAssassin Ni">
  
  
  <link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="/atom.xml">
  
  <meta name="description" content="A minimal hexo theme." />
  <meta name="apple-mobile-web-app-status-bar-style" content="black"/>
  <meta name="keywords" content="hexo,theme,typescript" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
  <meta property="og:type" content="website">
<meta property="og:title" content="随写 - XinoAssassin&#39;s Blog">
<meta property="og:url" content="https://xinoassasssin.github.io/tags/Hardware/index.html">
<meta property="og:site_name" content="随写 - XinoAssassin&#39;s Blog">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="随写 - XinoAssassin&#39;s Blog">
  
  
    <link rel="icon" href="/favicon.png">
  
  <script src="https://use.typekit.net/kqs5lfe.js"></script>
  <script>try{Typekit.load({ async: true });}catch(e){}</script>
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  

</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  Write Everything.
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          Home
        </a>
      
        <a href="/about" class="nav-about nav">
          About
        </a>
      
        <a href="/archives" class="nav-archives nav">
          Archives
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      
	<section class="page-header tag">
    <h1>- <span>Hardware</span> -</h1>
  </section>






<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/2018/08/before-Turing/">
      GeForce RTX 前瞻——在图灵架构初来乍到之时
    </a>
  </h2>
  
  <time>
    Aug 14, 2018
  </time>
  <section class="content">
	  <h2 id="终于确认的-Turing"><a href="#终于确认的-Turing" class="headerlink" title="终于确认的 Turing"></a>终于确认的 Turing</h2><p>距离 Nvidia 发布目前主流消费市场上的显卡—— GeForce 10 系列已经过去两年又三个月了，或许是因为竞争对手实在不给力，其推出的 Vega 系列没有撼动 Pascal 系显卡统治地位的能力，又或许是新卡的配套工程出了一些问题，比如制程问题还有 GDDR 6 显存的产量问题。</p>
<p><img src="/images/Roadmap-2015.jpg" width="75%" alt="2015 年 Roadmap"></p>
<p>这是一张 2015 年初，Nvidia 发布会上的路线图，上面可以很清楚地看到，Pascal 架构之后是 Volta 架构，横坐标对应着 2018。而 Volta 架构的亮相则是在去年年底，2017 年 12 月 7 日，老黄发布了 Titan V，一张价值 3000 美金的发烧级显卡。就在人们翘首期盼新的基于 Volta 架构的显卡之时，Nvidia 却迟迟没有发布新一代的 GeForce 系列，2018 年整个上半年，无数爱好者被时不时传出的一些 Nvidia 新卡的消息吊足了胃口，连新卡用的架构都有三个说法：Volta、Turing 还是 Ampere？直到 2018 年 8 月 13 日，Volta 之后的新架构 Turing 终于随着新一代 Quadro 专业级显卡正式登场了，而也证实了传闻中的 Turing 架构的真实性，以及爱好者们期待许久的新一代 GeForce 显卡就快要登场了，下面就是综合最近的一些消息对 GeForce 新系列的一些前瞻。</p>
<p><img src="/images/old-huang-with-QuadroRTX.jpg" width="65%" alt="老黄举着新的 Quadro RTX 显卡"></p>
<h2 id="RTX"><a href="#RTX" class="headerlink" title="RTX"></a>RTX</h2><p>我们先从命名说起。</p>
<p>新一代的 Quadro 专业级显卡的命名方式均为 Quadro RTX x000，而早前 Nvidia 注册了关于 RTX 的一些商标，这可能预示着新系列的 GeForce 显卡命名可能在顶级显卡上会放弃使用了十年之久的 GTX 前缀（后缀），而换用 RTX 作为新的前缀。</p>
<p>那么 RTX 又代表了什么？</p>
<p><strong>R</strong>ay <strong>T</strong>racing（光线追踪）然后带个 X。</p>
<p>熟悉游戏图形的朋友可能略微知道，目前桌面级游戏几乎都是基于光栅化的渲染方式，而大家经常看到的一些电影、游戏 CG 在渲染层面则是采用了实时光线追踪的方式。在桌面级平台上实现实时光线追踪这一目标是业界一直努力的一个方向，年初微软在 Windows 10 的更新中也为 DirectX 加入了新的光线追踪 API。而现在 Nvidia 终于将这一技术带到了桌面级平台上面，用业界专家的话来说：</p>
<blockquote>
<p>This is a significant moment in the history of computer graphics, Nvidia is delivering real-time ray tracing five years before we had thought possible.  –Jon Peddie, the well-respected CEO of analyst firm JPR and a noted graphics expert </p>
</blockquote>
<p><img src="/images/an-example-of-Ray-Tracing.jpg" width="65%" alt="实时光线追踪样图"></p>
<p>Nvidia 宣称其在新架构上新加入了一种 RT 单元专用于实时光线追踪，新架构在模拟真实世界场景上能 <strong>6 倍</strong>于前代，在实时光线追踪上则能做到 <strong>25 倍</strong>于帕斯卡架构。</p>
<p>所以 Nvidia 将这一特性作为新一代显卡的前缀来增强宣传作用是完全合理的。</p>
<p>这是两段近日发布的 Nvidia 的实时光线追踪的 Demo：</p>
<p><a href="https://www.youtube.com/watch?v=bFUWu387ErM" target="_blank" rel="noopener">https://www.youtube.com/watch?v=bFUWu387ErM</a></p>
<p><a href="https://www.youtube.com/watch?v=3jb3flTRykQ" target="_blank" rel="noopener">https://www.youtube.com/watch?v=3jb3flTRykQ</a></p>
<p>其中效果我只能用恁牛逼啊来叙述。</p>
<h2 id="GDDR6-显存"><a href="#GDDR6-显存" class="headerlink" title="GDDR6 显存"></a>GDDR6 显存</h2><p>不像 CPU，GPU 对于高速缓存的依赖非常之高，自 2008 年，HD 48x0 这代开始使用 GDDR5 显存到现在已经过去了十年，业界不断在为 GDDR5 续命，不过近些年来，AMD 在其高端卡上已经使用 HBM 取代了 GDDR5，而 Nvidia 也在 GTX 1080 上首次使用了 GDDR5X ，在 Titan V 上使用了 HBM 2 显存来获取更高的带宽。其继任者 GDDR6 标准在 2017 年 7 月被正式通过了，随后在今年年内，三星、镁光以及海力士这三家显存颗粒主要供应商都宣布开始出货 GDDR6 显存。</p>
<p>而 13 日 Quadro RTX 系列的发布证实了“Turing 架构将会使用 GDDR6 显存”的传闻，大概至少 GeForce 的旗舰级新卡会用上它吧。</p>
<h2 id="核心及其他改进"><a href="#核心及其他改进" class="headerlink" title="核心及其他改进"></a>核心及其他改进</h2><p>从现有的 Quadro 新卡来看，完整的 Turing 核心似乎是一个超大的核心，相比于 Pascal，其核心面积大了约 60%，晶体管数量多了约 58%，如果数字太过抽象，那么下面这张图就能很好地帮助你理解 Turing 到底大了多少。然而，即使较 Pascal 而言扩张了相当大的面积，Turing 仍然差 Volta 那么一筹（晶体管数量 21B，核心面积 815mm<sub>2</sub>）。</p>
<p><img src="/images/pascal-vs-turing.jpg" width="70%" alt="Pascal VS Turing"></p>
<p><img src="/images/turing-architecture.png" width="70%" alt="Turing 架构图"></p>
<p>这是官方发布会公布的 Turing 架构图，罗列一下现在已知的改进点：</p>
<ul>
<li>NVLINK 带宽增加了</li>
<li>Tensor 单元（Volta 架构引入的用于人工智能以及机器学习的单元）改进了</li>
<li>核心缓存改进了</li>
<li>视频引擎改进</li>
<li>输出支持 VirtualLink 以及 USB-C，支持新版 DisplayPort</li>
</ul>
<h2 id="11x0-or-20x0"><a href="#11x0-or-20x0" class="headerlink" title="11x0 or 20x0"></a>11x0 or 20x0</h2><p>近日，AIDA64 的新版本中包括了一些 Nvidia 的新 GPU，其中 GV 104 就被命名成了 GeForce GTX 1180。</p>
<p><img src="/images/AIDA64-1180.jpg" width="70%" alt="GeForce GTX 1180"></p>
<p>然而现在 Turing 架构的正式发布似乎标志着 AIDA64 出错了。首先，按照惯例，如果新一代 GeForce 显卡使用 Turing 架构，那么其核心代号则应该是 GT xxx，考虑到已经出现过 GT 系列核心代号（GeForce 100/200/300 系列），那么可能会使用别的代号也说不定，但是 GV 开头的可能性已经很小了。其次，按照上文 RTX 一节所说，新卡应该会以 RTX 为前缀而非 GTX。</p>
<p>就在 Quadro 新卡发布之后的 14 日上午，Nvidia GeForce 的官方推特发布了一个新的疑似预告片的<a href="https://twitter.com/NVIDIAGeForce/status/1029164596903337984" target="_blank" rel="noopener">短视频</a>，以 “#BeForTheGame” 命名，视频疑似预告了在 8 月 20 日科隆游戏展上 Nvidia 将会发布新一代桌面级显卡。在视频的第 45 秒，一个一闪而过的聊天信息中发现了有趣的东西：</p>
<p><img src="/images/video-45s.png" alt="45 秒"></p>
<p>内容是一个 RayTeX 的玩家和另一个 ID 为 Not_11 的玩家的对话。</p>
<blockquote>
<p>RayTeX: new build?</p>
<p>Not_11: No haha I wish, some got this at work</p>
<p>RayTeX: you getting on??</p>
<p>Not_11: eating, gimme 20</p>
</blockquote>
<p>两个非常有趣的 ID，一个缩写为 RTX 另一个叫不是 11，可能是官方剧透。最后一句 eating, gimme 20 与其 ID 相呼应，貌似下一代命名为 GeForce RTX 20x0 已经是板上钉钉的事情了。</p>
<p>但是新卡仍然没有发布，谁知道呢。</p>


    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/Everything/">Everything</a><a class="tag-link" href="/tags/Hardware/">Hardware</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2018/05/new-laptop/">
      再见，老伙计；你好，新朋友
    </a>
  </h2>
  
  <time>
    May 12, 2018
  </time>
  <section class="content">
	  <p>前略，上周日，一次突如其来的停电袭击之后，我那本来就已经处在崩溃边缘的 K610D 终于不得行了，进系统之后必蓝屏，而且此次蓝屏的 Code 还不一样（说实话可能我基本上把 Windows 10 能出现的蓝屏代码全看了一遍了）。花了半天尝试了各种修复后故障依旧，没有办法之下，只得跟父亲申请新机器的资金——其实已经延长了非常久的时间了，自从两年前进过水之后我就知道必然会有这么一天到来的——再花了四分之一天在限定资金下确定了现在这台新伙计，用的蓝天 W65KJ 的模具。<br>配置最基本两个大件新旧对比：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">K610D-i7d2</th>
<th style="text-align:center">W65KJ</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CPU</td>
<td style="text-align:center">Intel Core i7 4710MQ</td>
<td style="text-align:center">Intel Core i3 8100</td>
</tr>
<tr>
<td style="text-align:center">GPU</td>
<td style="text-align:center">NVIDIA GeForce 940M</td>
<td style="text-align:center">NVIDIA GeForce GTX 1050</td>
</tr>
</tbody>
</table>
<p>之所以新机器选择了 W65KJ, 原因有二：</p>
<ol>
<li><p>散热强劲</p>
<p>因为用的是桌面级 CPU, 所以 CPU 部分是用了双热管来压的，而且 CPU 与 dGPU 各用了一个风扇来分散热量。之前因为在 K610D 上面吃尽了散热差的苦头，所以这次舍弃了拥有更好扩展接口的另一个型号，也要散热系统非常强劲。</p>
<p>测试下来非常令我满意，在风扇全开的情况下能把 CPU 压在 65 度附近，四核频率稳定标称的 3.6 GHz 运行，dGPU 也压的非常好。</p>
</li>
<li><p>可扩展性强</p>
<p>因为用的是桌面级 Core 8 代 CPU, 所以机器上直接给了两个 M.2 接口，两个均支持 NVMe 协议。而且因为散热系统仍有余裕，所以后续升级至 Core i5 是非常可行的提升性能的办法，甚至 i7 都有一试之力。</p>
</li>
</ol>
<p>京东速度还算是不错，第二天周一中午机器到手的时候是 8GB 2400 的英睿达单条 DDR4 内存加上一条金士顿的 128 GB 的 TLC 条子，成本原因自然是走 SATA 协议的，但是够用是够用了，就是容量太小了，于是当天下午就下单了另一条英睿达 DDR4 2400 8GB 和三星的 SM961 256GB, 最谢天谢地的是最近的内存条和 SSD 都有一些降价，不然得是大出血。</p>
<p>犹豫是周一下午五点——一般快递停收时间——之后才淘宝下的单，所以内存到了周五才到，而 SM961 却到了周三还没发货，咨询了卖家：“没货，明天或者后天到”。我可去你妈的，换店，之前物色 NVMe SSD 的时候在 XG3 和 SM961 之间纠结，然后这时候在淘宝上看到一家拆机 XG3 512GB 才卖九百出头的店，果断付款。</p>
<p>然后今天周六下午，终于是到手了。赶紧插上装好东芝家的驱动跑个分，果然 NVMe + MLC 的组合数据上非常吓人。马上迁移系统，结果文件都是复制完了却在启动上栽了跟头。</p>
<h2 id="系统迁移引导处理"><a href="#系统迁移引导处理" class="headerlink" title="系统迁移引导处理"></a>系统迁移引导处理</h2><p>在 UEFI + GPT 环境下直接复制全盘复制文件到新分区是可行的，前提是你的 NVMe 在原来的系统中要被认过一次，系统的设备管理器中的“存储控制器”一项出现了 NVMe 控制器，这是迁移可行的大前提。</p>
<p>文件复制完毕之后，你还需要做两个事情，否则，是进不去新驱动器上的系统的：</p>
<h3 id="改变注册表中默认分配盘符"><a href="#改变注册表中默认分配盘符" class="headerlink" title="改变注册表中默认分配盘符"></a>改变注册表中默认分配盘符</h3><p>首先你需要一个可用的注册表编辑器，定位到 <code>HKLM\SYSTEM\MountedDevices</code> 下，将 <code>\DosDevices\新系统所在的盘符:</code> 的值复制下来。挂载上新系统的注册表文件（通过文件-加载配置单元读取 <code>Windows\System32\Config\SYSTEM</code> 文件），然后定位到相同的项，将之前复制的值覆盖掉 <code>\DosDevices\C:</code> 的值即可。</p>
<h3 id="写入新的-BCD-配置"><a href="#写入新的-BCD-配置" class="headerlink" title="写入新的 BCD 配置"></a>写入新的 BCD 配置</h3><p>然后你需要一块系统安装盘，启动到系统安装界面，调出命令行(Shift + F10), 然后将新系统所在的分区的盘符挂成 “C”, 同时要给新硬盘上的 ESP 分区分配一个盘符，使程序能够写入文件，大概过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">diskpart</span><br><span class="line">list disk &apos;查看磁盘列表</span><br><span class="line">sele disk x &apos;x 是你新磁盘在列表中的编号</span><br><span class="line">list part</span><br><span class="line">sele part x &apos;x 是你新系统所在的分区编号</span><br><span class="line">assign letter=C &apos;分配新系统所在分区的盘符为 C</span><br><span class="line">sele part y &apos;y 是这块磁盘上的 ESP 分区编号</span><br><span class="line">assign letter=Y &apos;给 ESP 分区分配 Y 的盘符</span><br><span class="line">exit &apos;退出 diskpart</span><br><span class="line">bcdboot C:\windows /s Y: [/v] &apos;将 C:\Windows 作为启动目录写入到 Y: 上，&quot;/v&quot; 为可选参数，即详细模式</span><br></pre></td></tr></table></figure>
<p>重启之后就搞定了。</p>
<hr>
<p>那么，这台机子就这么算是正式启用了吧，之后会攒钱买块 Core i5 给换上就算是完全大功告成了，但愿它能陪我长一些时间吧。</p>


    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/Everything/">Everything</a><a class="tag-link" href="/tags/Hardware/">Hardware</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2018/03/about-AA/">
      关于抗锯齿
    </a>
  </h2>
  
  <time>
    Mar 11, 2018
  </time>
  <section class="content">
	  <p>今天听 Gadio News 的时候，最末尾一段提到了希望有人能来讲讲抗锯齿技术。才疏学浅，但是前几年看 MC 的文章还是知道一点相关内容，所以就来看着维基写写看，如有不正之处劳请指出。</p>
<h2 id="锯齿与抗锯齿"><a href="#锯齿与抗锯齿" class="headerlink" title="锯齿与抗锯齿"></a>锯齿与抗锯齿</h2><p>首先，什么是锯齿，以及为什么会出现锯齿。</p>
<p>我们的屏幕，是以一个个正方形的像素点组成的，而正方形的特性导致了在倾斜的线上，边缘必定会出现一个个突起的阶梯状“毛刺”，比如图上这种<img src="/images/04fb3bbbec0c10e70c660aac1efd7cf1_r.jpg" alt="preview"></p>
<p>这种阶梯状的“毛刺”就是典型的锯齿。而有了锯齿也就有了抗锯齿(Anti-Aliasing).</p>
<p>抗锯齿的一般过程就是将这个毛刺的边缘柔化，使图像边缘看起来更平滑。如图：<img src="/images/4ec755cfd484c8333f094f57b97f3408_hd.jpg" alt="img"></p>
<h2 id="各种算法简单介绍"><a href="#各种算法简单介绍" class="headerlink" title="各种算法简单介绍"></a>各种算法简单介绍</h2><p>抗锯齿算法种类非常多，下面的介绍顺序基本上是各种抗锯齿算法出现的时间顺序。</p>
<h3 id="SSAA"><a href="#SSAA" class="headerlink" title="SSAA"></a>SSAA</h3><p>超级采样抗锯齿(Super-Sampling Anti-Aliasing, 也可叫做 Supersampling 超采样)是最早也最简单粗暴的抗锯齿手法，它的原理非常简单，就是在渲染时将要输出的分辨率提升 x 倍，比如要输出 1920x1080 的分辨率到屏幕上，开启 SSAA 2x, 那么内部渲染时的分辨率就是 3840x2160, 然后 Downsampling 到 1920x1080 上，自然在许多纹理边缘上就显得平滑许多。但是这种方式太太太吃资源了，所以又开发出了新的算法。</p>
<p>在 Nvidia 发布二代 Maxwell 架构的时候，同时发布的 <a href="http://www.geforce.cn/hardware/technology/dsr/technology" target="_blank" rel="noopener">DSR</a> 技术中就有 SSAA 的影子，技术思路同样是以更高分辨率渲染的原始画面输出到显示器分辨率上来得到更加精细平滑的画面。</p>
<h3 id="MSAA"><a href="#MSAA" class="headerlink" title="MSAA"></a>MSAA</h3><p>SSAA 太吃资源了，我们的硬件暂时还跟不上，怎么办？于是就有了多重采样抗锯齿(Multi-Sampling Anti-Aliasing), 它跟 SSAA 的区别就是，MSAA 只对于多边形的边缘进行抗锯齿处理。比如一个红色的圆，只对圆周作抗锯齿多重采样计算，但是圆周以内的部分则不会处理。这种方式下的画面锯齿得到了一定的抑制，而抗锯齿需要的资源也大幅下降到可接受的范围中。所以 MSAA 也逐渐成为目前被使用的最多的抗锯齿技术。</p>
<p>但是 MSAA 也有其局限之处，比如对于半透明物件、边缘不明确或者非常复杂的物件比如密集草丛、铁丝网这类的抗锯齿处理就比较力不从心。</p>
<h3 id="CSAA-amp-CFAA"><a href="#CSAA-amp-CFAA" class="headerlink" title="CSAA &amp; CFAA"></a>CSAA &amp; CFAA</h3><p>历史进入 Direct 10 时代，NV 方先声夺人发布了 G80 系列，同时带来了覆盖采样抗锯齿(<a href="http://www.nvidia.com/object/coverage-sampled-aa.html" target="_blank" rel="noopener">Coverage-Sampling Anti-Aliasing</a>)技术，主要改进了取样类型从而使得抗锯齿效率提升，资源占用量也得到减少。举例来说，如果使用 16x MSAA，需要在周围取得 16 个采样点的色彩值和 Z 轴值，然后保存这些数值进行计算。而 16x CSAA，则全部在被采样的像素点中心取得色彩之和Z轴值，然后对比并去掉同样的数据。一般来说，16x CSAA 后只需要保存 4 份色彩值和 Z 轴值即可。换句话来说，4x MSAA 耗费的资源和 16x CSAA 是相同的，但是，16x CSAA的画面效果相比 4x MSAA 更好。</p>
<p>同期 ATI 在发布 R600 系列时也带来了可编程过滤抗锯齿(Custom Filter Anti-Aliasing)技术。简单的来说 CFAA 就是扩大取样面积的 MSAA，比方说之前的 MSAA 是严格选取物体边缘像素进行缩放的，而 CFAA 则可以通过驱动判断对影响锯齿效果较大的像素进行缩放，以较少的性能牺牲换取平滑效果。</p>
<p>但是由于种种原因，CSAA 被接受程度更高一些，不少游戏就直接加入了 CSAA 选项。而 CFAA 由于需要在显卡驱动面板中进行调试而渐渐被用户所遗忘。</p>
<h3 id="MLAA-amp-FXAA"><a href="#MLAA-amp-FXAA" class="headerlink" title="MLAA &amp; FXAA"></a>MLAA &amp; FXAA</h3><p>在 CFAA 被遗忘之后，AMD-ATI 带来了形态抗锯齿(Morphological Anti-Aliasing).</p>
<p>不同于上面几种需要对多边形边缘进行分析计算的算法，MLAA 是一种后处理技术，发生在整个 3D 计算完成即将输出画面到屏幕上前，打个比方就是你拍完照用 Photoshop 处理的过程。</p>
<p>MLAA 的实际效果还是非常不错的，但是资源耗用还是有点厉害的。它的最大优势就是不需要游戏来支持它，因为是后处理技术所以在显卡驱动面板中打开就能用而且兼容性非常好。但是由于其仅仅使用颜色数据来判断抗锯齿边缘，因此 MLAA 的应用可能导致无法辨识到底哪些边缘需要进行抗锯齿计算。特别是一些不需要抗锯齿的地方，如文字，表格等，可能都由于不当抗锯齿而显得圆滑甚至怪异。</p>
<p>这边 A 家出了新抗锯齿技术，老冤家 NV 当然也不甘落后，在 Fermi 上推出了快速近似抗锯齿(Fast Approximate Anti-Aliasing)。</p>
<p>FXAA 和 MLAA 一样，也是一种后处理抗锯齿，两种 AA 在原理上相似，但是由于 FXAA 可以在 AN 两家的卡上都可以用而 MLAA 则由于部分计算处理依赖于硬件所以只能在 A 卡上用，最后导致 FXAA 被广泛的采用了。而且同时期 FXAA 的性能损失比 MLAA 更小，而效果上基本能接近 4x MSAA 的画面，虽然同样还是会出现“字体破坏”的情况。</p>
<h3 id="TXAA"><a href="#TXAA" class="headerlink" title="TXAA"></a>TXAA</h3><p>在抗锯齿这条路上，众多程序员以及各种“家”的探索是不会停下来的。在 Kepler 架构发布的同时，NV 也带来了新的 <a href="http://www.geforce.cn/hardware/technology/txaa/technology" target="_blank" rel="noopener">TXAA</a>(Temporal Anti-Aliasing 可称为“时间性抗锯齿”)技术，据 NV 自家的介绍，这项技术集时间性过滤器、硬件抗锯齿以及定制的 CG 电影式抗锯齿解算法于一身。</p>
<p>原有的抗锯齿技术在解决静态画面的锯齿上可以说已经达到了瓶颈了，但是在动态画面上，有锯齿的部位很容易出现闪烁。如同其名字中的“时间性”，TXAA 旨在解决“时间性抗锯齿”，也就是动态画面中的锯齿闪烁等问题。而其同时提供着不输于 8x MSAA 的静态画面抗锯齿效果。</p>
<p>TXAA 可以说是目前被采用的较多的抗锯齿算法中最厉害的一种了，但是它一是需要硬件电路配合，二是吃资源，以性能换画面，所以也基本上是中高端 N 卡用户用的。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>目前主流的一些抗锯齿技术大概就是这么多了，本文很多内容都是参考中文互联网上的一些文章写成的。第一次在机核发文，存在的许多不足之处也请多多包涵。</p>


    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/Everything/">Everything</a><a class="tag-link" href="/tags/Game/">Game</a><a class="tag-link" href="/tags/Hardware/">Hardware</a>
	  </div>
    

  </section>
</article>
  
</section>


      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <form name="searchform" id="searchform" class="u-search-form">
	    <input type="text" id="searchinput" class="u-search-input" placeholder="Looking for something?" />
	    <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit">
	      <span class="icon icon-search"></span>
	    </button>
	  </form>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:phnjs211@gmail.com" class="social email"
          target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/xinoassassin" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/xinoassassin" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="http://weibo.com/XiDeAssassin" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="https://rakugaki.me/" target="_blank">Art Chen</a>,<br/> modified by XinoAssassin.</div>
  <div>&copy; <a href="/">随写 - XinoAssassin&#39;s Blog</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  



<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>

<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
